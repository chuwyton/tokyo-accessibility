---
title: "Analysing Hotel Prices"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

ggmap was used in this exploratory script.
CRS: Japanese Geodetic Datum 2011 (54N). This encompasses Tokyo and is the most precise. EPSG: 6691

```{r Setup, include=F}
library(tidyverse)
library(jsonlite)
library(sf)
library(sp)
library(spdep)
library(ggmap)
library(tmap) #for exploration
library(GGally) # for pairs, mostly
library(osmdata)
library(opentripplanner)
library(httr)
library(xml2)
library(curlconverter)
# library(rvest)
# library(RSelenium)

tmap_mode("view")

apikey = readLines(here::here("data/apikey.txt"))
```

```{r Prefix Suffix definitions, include=F}
######## SUFFIXES
### _aggr: the dataset that this variable points to is aggregated.
```

#Non-Spatial Analysis  

We will first look at non-spatial analysis of hotels in Tokyo.

```{r Scrape hotels, eval=F, include=F}
# 6~7 Nov, 1 adult, 1 room
# build fetch

cmd = "curl 'https://www.expedia.com/hotel-shop/api/1/en_US/hotels?accessibility=&amenities=&destination=Tokyo%20(and%20vicinity)%2C%20Japan&endDate=2019-11-07&latLong=35.675%2C139.76&lodging=&paymentType=&price=&regionId=179900&sort=recommended&startDate=2019-11-06&travelerType=&useRewards=true&localDateFormat=M%2Fd%2Fyyyy&priceFilterBuckets=&count=50&startingIndex=100&adults=1' -H 'accept-encoding: gzip, deflate, br' -H 'accept-language: en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6,ja;q=0.5' -H 'x-remote-addr: 103.24.77.51, 96.17.180.174, 125.56.219.90, 10.7.22.119, 52.220.191.232' -H 'cookie: tpid=v.1,1; iEAPID=0; currency=USD; linfo=v.4,|0|0|255|1|0||||||||1033|0|0||0|0|0|-1|-1; HMS=8eb7de8a-4f9c-48e9-af6c-37569e4953ca; DUAID=66cca9d4-baf2-410f-8365-6288c866691e; MC1=GUID=66cca9d4baf2410f83656288c866691e; ak_bmsc=2CE9B6A63AC897D59852F5211CEBAEF06011B4AE6A60000062542C5DC32A1816~plIdWDwJQecFy6mA/nhsX02W/Mj4berGkhXPNqh/2ATQLmynxQHYAlXl7SCFZzn0ETD3EbKru9s4vkAgCfSq2EF4el/2JdgH8j85jGXsCb/gBrI90XKgK8XTdG7DI314zn7kyKa7Uvnp7FJvRhF7/cTN/wkt8vD/r4sBbwY1JNXmfJCSgB16+y9W/JgzXNOnK23paCqQ5RNrMUY3OH9+EPWp3wxvOClusQVT/NMMp2AKA=; AMCVS_C00802BE5330A8350A490D4C%40AdobeOrg=1; aspp=v.1,0|||||||||||||; stop_mobi=yes; JSESSIONID=7D73FBF9F8078EE5B8F5BCD914A66378; s_ecid=MCMID%7C33131617227363293851514339830081388369; AMCV_C00802BE5330A8350A490D4C%40AdobeOrg=1406116232%7CMCIDTS%7C18093%7CMCMID%7C33131617227363293851514339830081388369%7CMCAAMLH-1563791070%7C3%7CMCAAMB-1563791070%7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y%7CMCOPTOUT-1563193470s%7CNONE%7CMCAID%7CNONE%7CvVersion%7C2.5.0; s_cc=true; CONSENTMGR=ts:1563186271727%7Cconsent:true; AB_Test_TripAdvisor=A; qualtrics_sample=false; rlt_marketing_code_cookie=; qualtrics_SI_sample=false; ipsnf3=v.3|us|1|753|chandler; JSESSION=c50a1783-393c-46ee-8ab0-db868fc44635; intent_media_prefs=; _gcl_au=1.1.1825130036.1563186272; __gads=ID=2b5a47aa8ae5e1da:T=1563186275:S=ALNI_MaLqKpR9M90UcseTvO2fM9DRd2VIg; im_snid=4c52d204-9959-4169-b870-7eed0cb82b28; _ga=GA1.2.615676407.1563186272; _gid=GA1.2.1463963763.1563186273; _gat_gtag_UA_35711341_2=1; _fbp=fb.1.1563186272743.1212476019; _tq_id.TV-721872-1.7ec4=e9fe8c18af11ea4e.1563186273.0.1563186273..; xdid=340fe610-5e53-41ff-962a-aba253adeb0d|1563186277|expedia.com; x-CGP-exp-30353=3; x-CGP-exp-15795=2; x-CGP-exp-28702=0; pwa_csrf=b8933d54-eebb-4ddc-a92c-33e04a147603|6BQK3yOPKGEw5Y3yfS25QxhjzV3aP_DkcczvTFm13FjfGtca9c5X54oK6qyptC6FYqM0gnUSPy16dBgZ3LaCEw; x-cgp-exp=27461.79023.pwa; x-CGP-exp-27461=1; s_ppn=page.Hotel-Search; utag_main=v_id:016bf52995f30015c9989cde72f303073001806b00bd0$_sn:1$_ss:0$_pn:2%3Bexp-session$_st:1563188088847$ses_id:1563186271731%3Bexp-session; cesc=%7B%22visitNumber%22%3A%5B%221%22%2C1563186274123%5D%2C%22cidVisit%22%3A%5B%22Brand.DTI%22%2C1563186292494%5D%2C%22entryPage%22%3A%5B%22Homepage%22%2C1563186292494%5D%2C%22cid%22%3A%5B%22Brand.DTI%22%2C1563186274123%5D%7D; s_ppvl=Homepage%2C24%2C24%2C969%2C1364%2C969%2C1920%2C1080%2C1%2CP; _ctz_plugin_opt=0; s_ppv=Homepage%2C100%2C24%2C9675%2C1364%2C969%2C1920%2C1080%2C1%2CP; IM_eu_freq_cap=Y' -H 'x-user-state: anonymous' -H 'x-user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36' -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36' -H 'content-type: application/json' -H 'accept: application/json' -H 'referer: https://www.expedia.com/Hotel-Search?destination=Tokyo%2C+Japan&latLong=35.675%2C139.76&regionId=179900&startDate=11%2F06%2F2019&endDate=11%2F07%2F2019&rooms=1&adults=1' -H 'authority: www.expedia.com' -H 'x-mc1-guid: 66cca9d4-baf2-410f-8365-6288c866691e' -H 'x-api-token: 83b54f81b7055087cc1096b4bbbbeeaf868dd080' --compressed"

url = "https://www.expedia.com/"
path = "hotel-shop/api/1/en_US/hotels"
query = c(accessibility = "",
          amenities = "",
          destination = "Tokyo (and vicinity), Japan",
          endDate = "2019-11-07",
          latLong = "35.675,139.76",
          lodging = "",
          paymentType = "",
          price = "",
          regionId = "179900",
          sort = "recommended",
          startDate = "2019-11-06",
          travelerType = "",
          userRewards = "true",
          localDateFormat = "M/d/yyyy",
          priceFilterBuckets = "",
          count = "2000",
          startingIndex = "1",
          adults = "1")

response = GET(url = url,
               query = query,
               add_headers(.headers = c("accept-encoding" = "gzip, deflate, br",
                      "accept-language" = "en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6,ja;q=0.5",
                      "x-remote-addr" = "103.24.77.51, 96.17.180.174, 125.56.219.90, 10.7.22.119, 52.220.191.232",
                      "cookie" = "tpid=v.1,1; iEAPID=0; currency=USD; linfo=v.4,|0|0|255|1|0||||||||1033|0|0||0|0|0|-1|-1; HMS=8eb7de8a-4f9c-48e9-af6c-37569e4953ca; DUAID=66cca9d4-baf2-410f-8365-6288c866691e; MC1=GUID=66cca9d4baf2410f83656288c866691e; ak_bmsc=2CE9B6A63AC897D59852F5211CEBAEF06011B4AE6A60000062542C5DC32A1816~plIdWDwJQecFy6mA/nhsX02W/Mj4berGkhXPNqh/2ATQLmynxQHYAlXl7SCFZzn0ETD3EbKru9s4vkAgCfSq2EF4el/2JdgH8j85jGXsCb/gBrI90XKgK8XTdG7DI314zn7kyKa7Uvnp7FJvRhF7/cTN/wkt8vD/r4sBbwY1JNXmfJCSgB16+y9W/JgzXNOnK23paCqQ5RNrMUY3OH9+EPWp3wxvOClusQVT/NMMp2AKA=; AMCVS_C00802BE5330A8350A490D4C%40AdobeOrg=1; aspp=v.1,0|||||||||||||; stop_mobi=yes; JSESSIONID=7D73FBF9F8078EE5B8F5BCD914A66378; s_ecid=MCMID%7C33131617227363293851514339830081388369; AMCV_C00802BE5330A8350A490D4C%40AdobeOrg=1406116232%7CMCIDTS%7C18093%7CMCMID%7C33131617227363293851514339830081388369%7CMCAAMLH-1563791070%7C3%7CMCAAMB-1563791070%7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y%7CMCOPTOUT-1563193470s%7CNONE%7CMCAID%7CNONE%7CvVersion%7C2.5.0; s_cc=true; CONSENTMGR=ts:1563186271727%7Cconsent:true; AB_Test_TripAdvisor=A; qualtrics_sample=false; rlt_marketing_code_cookie=; qualtrics_SI_sample=false; ipsnf3=v.3|us|1|753|chandler; JSESSION=c50a1783-393c-46ee-8ab0-db868fc44635; intent_media_prefs=; _gcl_au=1.1.1825130036.1563186272; __gads=ID=2b5a47aa8ae5e1da:T=1563186275:S=ALNI_MaLqKpR9M90UcseTvO2fM9DRd2VIg; im_snid=4c52d204-9959-4169-b870-7eed0cb82b28; _ga=GA1.2.615676407.1563186272; _gid=GA1.2.1463963763.1563186273; _gat_gtag_UA_35711341_2=1; _fbp=fb.1.1563186272743.1212476019; _tq_id.TV-721872-1.7ec4=e9fe8c18af11ea4e.1563186273.0.1563186273..; xdid=340fe610-5e53-41ff-962a-aba253adeb0d|1563186277|expedia.com; x-CGP-exp-30353=3; x-CGP-exp-15795=2; x-CGP-exp-28702=0; pwa_csrf=b8933d54-eebb-4ddc-a92c-33e04a147603|6BQK3yOPKGEw5Y3yfS25QxhjzV3aP_DkcczvTFm13FjfGtca9c5X54oK6qyptC6FYqM0gnUSPy16dBgZ3LaCEw; x-cgp-exp=27461.79023.pwa; x-CGP-exp-27461=1; s_ppn=page.Hotel-Search; utag_main=v_id:016bf52995f30015c9989cde72f303073001806b00bd0$_sn:1$_ss:0$_pn:2%3Bexp-session$_st:1563188088847$ses_id:1563186271731%3Bexp-session; cesc=%7B%22visitNumber%22%3A%5B%221%22%2C1563186274123%5D%2C%22cidVisit%22%3A%5B%22Brand.DTI%22%2C1563186292494%5D%2C%22entryPage%22%3A%5B%22Homepage%22%2C1563186292494%5D%2C%22cid%22%3A%5B%22Brand.DTI%22%2C1563186274123%5D%7D; s_ppvl=Homepage%2C24%2C24%2C969%2C1364%2C969%2C1920%2C1080%2C1%2CP; _ctz_plugin_opt=0; s_ppv=Homepage%2C100%2C24%2C9675%2C1364%2C969%2C1920%2C1080%2C1%2CP; IM_eu_freq_cap=Y",
                      "x-user-state" = "anonymous",
                      "x-user-agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36",
                      "user-agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36",
                      "content-type" = "application/json",
                      "accept" = "application/json",
                      "referer" = "https://www.expedia.com/Hotel-Search?destination=Tokyo%2C+Japan&latLong=35.675%2C139.76&regionId=179900&startDate=11%2F06%2F2019&endDate=11%2F07%2F2019&rooms=1&adults=1",
                      "authority" = "www.expedia.com",
                      "x-mc1-guid" = "66cca9d4-baf2-410f-8365-6288c866691e",
                      "x-api-token" = "83b54f81b7055087cc1096b4bbbbeeaf868dd080")))
```


```{r Get hotels, eval=F}
#NEW search condition: 6 - 7 November 2019, 1 adult 1 room.

get_hotels = function(path) {
  test = read_json(path)$hotels %>% keep(~.x$type == "HotelViewModel")
  test_tibble = tibble(hotelId = map(test, "hotelId") %>% unlist(),
                       hotelName = map(test, "hotelName") %>% unlist(),
                       #shortlistModel = map(test, "shortlistModel"),
                       displayPrice = map(test, "displayPrice") %>% unlist(),
                       latitude = map(test, "latitude") %>% unlist(),
                       longitude = map(test, "longitude") %>% unlist(),
                       hotelFlags = map(test, "hotelFlags"),
                       price = map(test, "price"),
                       neighborhood = map(test, "neighborhood") %>% unlist(),
                       reviews = map(test, "reviews"),
                       resultType = map(test, "resultType") %>% unlist(),
                       comparisonModel = map(test, "comparisonModel")) %>% 
    drop_na() %>% 
    mutate(price.lead = map(price, "lead") %>% unlist(),
           price.strikeout = map(price, "strikeOut", .default = NA_character_) %>% unlist(),
           reviews.localizedOverallRating = map(reviews, "localizedOverallRating") %>% unlist(),
           reviews.localizedCount = map(reviews, "localizedCount") %>% unlist(),
           reviews.superlative = map(reviews, "superlative", .default = NA_character_) %>% unlist(),
           comparisonModel.amenities = map(comparisonModel, "amenities"),
           comparisonModel.starRating = map(comparisonModel, "starRating") %>% unlist()) %>% 
    mutate(displayPrice = parse_number(displayPrice),
           latitude = parse_number(latitude),
           longitude = parse_number(longitude),
           price.lead = parse_number(price.lead),
           price.strikeout = parse_number(price.strikeout),
           reviews.localizedOverallRating = parse_number(reviews.localizedOverallRating),
           reviews.localizedCount = parse_number(reviews.localizedCount),
           reviews.superlative = parse_factor(reviews.superlative,
                                              levels = c(NA_character_, "Good", "Very Good", "Excellent", "Wonderful", "Exceptional"),
                                              ordered = T)) %>% 
    mutate(price.strikeout = if_else(is.na(price.strikeout), price.lead, price.strikeout)) %>% 
    select(hotelId, 
           hotelName, 
           neighborhood, 
           price.lead, 
           price.strikeout,
           reviews.superlative,
           reviews.localizedOverallRating,
           reviews.localizedCount,
           comparisonModel.starRating,
           latitude,
           longitude,
           hotelFlags, 
           comparisonModel.amenities,
           comparisonModel)

  return(test_tibble)
}

# tb = get_hotels("data/Hotels/Expedia_hotels_150.json")

assumedLocation = here::here("data/Hotels/Expedia_hotels.zip")
if(file.exists(assumedLocation)){
  local_path = assumedLocation
} else {
  local_path = choose.files(default = here::here(), caption = "Select zip folder containing Expedia hotel jsons", multi = F)
}

local_path %>% unzip(exdir = here::here("data/Hotels/Expedia_hotels"))
hotels = here::here("data/Hotels/Expedia_hotels") %>% list.files(pattern = "*.json", full.names = T) %>% map(get_hotels) %>% bind_rows()
```

```{r Get hotels rds}
hotels = read_rds(here::here("data/hotels.rds"))
```

##Hexagonal grids

Before moving on, I'll create the boundary for my research, and cut it into grids. This allows us to scope the hotels down to only the specific area we're looking at.

```{r Get line data, eval=F}
# bounding box
bb_tokyo = getbb("Tokyo")


# queries
q_linebase = bb_tokyo %>% 
  opq(timeout = 60) %>% 
  add_osm_feature("route", "train")

q_yamanote = q_linebase %>% 
  add_osm_feature("name:en", "JR Yamanote Line (Outer)")

q_chuo = q_linebase %>% 
  add_osm_feature("name:en", "JR Chuo Rapid Line")

# q_uenotokyo = q_linebase %>% 
#   add_osm_feature("name:en", "Ueno-Tokyo Line (down)")

q_keihintohoku = q_linebase %>% 
  add_osm_feature("ref", "JK") %>% 
  add_osm_feature("from:en", "Omiya")

# retrieval
yamanote_sf     = osmdata_sf(q_yamanote    )$osm_lines %>% st_transform(6677) %>% select(osm_id, name.en)
chuo_sf         = osmdata_sf(q_chuo        )$osm_lines %>% st_transform(6677) %>% select(osm_id, name.en)
keihintohoku_sf = osmdata_sf(q_keihintohoku)$osm_lines %>% st_transform(6677) %>% select(osm_id, name.en)

#good to include other lines also
```

```{r Get lines rds, include=F}
yamanote_sf     = read_rds(here::here("data/yamanote_sf.rds"))
chuo_sf         = read_rds(here::here("data/chuo_sf.rds"))
keihintohoku_sf = read_rds(here::here("data/keihintohoku_sf.rds"))
```

```{r Get grid}
yamanote_area = yamanote_sf %>% 
  st_union() %>% 
  st_convex_hull() %>% 
  st_buffer(1000)

yamanote_area_grid = yamanote_area %>% 
  st_make_grid(square = F, cellsize = 500) %>% 
  st_sf() %>% 
  rowid_to_column("grid.id")
```

```{r consolidate lines}
lines_sf = rbind(yamanote_sf, chuo_sf, keihintohoku_sf) %>% 
  st_join(yamanote_area_grid) %>% 
  na.omit() %>% 
  mutate(col = case_when(name.en == "Yamanote Line"      ~ "#80c241",
                         name.en == "JR Chuo Line"       ~ "#f15a22",
                         name.en == "Chuo Line"          ~ "#f15a22",
                         name.en == "Keihin-Tohoku Line" ~ "#00b2e5"))

tm_base = tm_shape(lines_sf) +
  tm_sf(col = "col", alpha = 0.4) +
  tm_basemap(server = "OpenStreetMap", alpha = 0.4)
```

```{r hotel inclusion}

# Check inclusion
hotels_sf = hotels %>% 
  select(hotelName, everything()) %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 6668) %>% 
  st_transform(6677)

hotels_sf = hotels_sf %>% 
  mutate(within.boundary = st_within(., yamanote_area_grid) %>% lengths()) %>% 
  mutate(within.boundary = ifelse(within.boundary == 0, "No", "Yes"))

tm_shape(yamanote_area_grid) +
  tm_fill(col = "grey", alpha = 0.4) +
  tm_shape(hotels_sf) +
  tm_dots(col = "within.boundary", title="Falls within boundary") +
  tm_layout(title = "Inclusion of hotels") +
  tm_base
```

Altogether, `r nrow(filter(hotels_sf, within.boundary == "Yes"))` out of `r nrow(hotels_sf)` hotels fall in the central area.

```{r Prune data}
#...to include only those in the yamanote region.

hotels_sf = hotels_sf %>% filter(within.boundary == "Yes")
hotels = hotels_sf %>% st_set_geometry(NULL)
```

With the hotels which fall outside of our area of research put aside, we can now look at the various distributions of the remaining hotels.

```{r Quick check: general distribution}
hotels %>% select(reviews.localizedOverallRating, comparisonModel.starRating) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  geom_bar(stat = "count") +
  facet_wrap(~key, scales = "free_x", labeller = labeller(key = c(reviews.localizedOverallRating = "Overall rating",
                                                                  comparisonModel.starRating = "Star rating"))) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.title.x = element_blank()) +
  labs(title = "General distribution of hotels",
       subtitle = "Overall rating, Star rating",
       y = "Number of hotels")

hotels %>% select(reviews.localizedOverallRating, comparisonModel.starRating, price.lead, price.strikeout) %>% 
  gather(key = "key", value = "value", -price.lead, -price.strikeout) %>% 
  gather(key = "price.type", value = "price", -key, -value) %>% 
  ggplot(aes(x = value, y = price, group = value)) +
  geom_boxplot(position = "dodge2") +
  facet_grid(price.type~key, 
             scales = "free_x", 
             labeller = labeller(key = c(reviews.localizedOverallRating = "Overall rating",
                                         comparisonModel.starRating = "Star rating",
                                         price.lead = "Lead price",
                                         price.strikeout = "Strikeout price"))) +
  theme_minimal() +
  theme(axis.title.x = element_blank()) +
  labs(title = "Price distribution of hotels",
       subtitle = "By Overall rating, Star rating",
       y = "Price")
```

There are two types of prices shown in Expedia: the "lead" price and the "strikeout" price. The strikeout price is not always present, but if it is, it is always more than the lead price. the strikeout price is then displayed in a grey colour and "struck through", indicating that the lead price is a "special" price to the customer. Expedia explains that this price is "the third highest price for this room type at this property (with the same length of stay and cancellation policy) that customers have found on our site during a 30 day window" around the selected check-in date.

This leads to some differences in the boxplots shown below, but nothing that would lead to drastic changes in regression analyses. For convenience the lead price will be used.

We definitely see an upward trend in room prices for star rating. As for the overall rating, the prices peak at 4.7, and then go down, meaning that hotels with a rating higher than 4.7 actually enjoy a lowesr room price. This is probably because customers take the price into account when rating hotels.

```{r Quick check: general distribution 2}
hotels %>% group_by(neighborhood) %>% 
  summarise(count = n()) %>% 
  ggplot(aes(x = reorder(neighborhood, -count), y = count)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "General distribution of hotels",
       subtitle = "Neighbourhood",
       y = "Number of Hotels", x = "Neighbourhood") +
  coord_flip()

hotels %>%  
  ggplot(aes(x = fct_reorder(neighborhood, price.lead), y = price.lead)) +
    geom_boxplot() +
    theme_minimal() +
    labs(title = "General price distribution of hotels",
         subtitle = "by Area",
         caption = "*unit: S$/person/night",
         y = "Price", x = "Neighbourhood") +
  coord_flip()
```

*In general, most hotels are classified under "Tokyo". Thus, Tokyo also has the larges range of prices. I'm not sure if explaining the variances in areas makes any sense, because the areas themselves seem to be quite poorly classified to begin with.*

```{r Quick check: spatial distr}
hotels_sf %>% 
  tm_shape() +
  tm_dots(col = "price.lead", title = "Price", style = "jenks") +
  tm_layout(title = "Price distribution of hotels") +
  tm_base

# get_map("Tokyo") %>% ggmap() +
#   geom_sf(data = hotels_sf)
```

There is a number of hotels which follow the trend that hotels closer to large stations (see Tokyo, Shinjuku) are pricier. Otherwise, a good mix exists.

```{r Quick check: spatial distr nbh}
hotels_sf %>% 
  tm_shape() + 
  tm_dots(col = "neighborhood") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Neighborhood distribution of hotels")
```

*This just shows how the hotels are grouped according to Expedia.*

```{r Quick check: pairs}
hotels %>% 
  ggpairs(columns = c("price.lead", 
                      "reviews.localizedOverallRating",
                      "comparisonModel.starRating"),
          mapping = aes(alpha = 0.4))
```

These are paired plots for price (strikeout -- un-discounted prices), overall rating, and star rating. There is a good (0.6) correlation between the price and the star rating, and a slightly-less good correlation between review rating and star rating. As demonstrated in the boxplots, hotels of all prices can exist along a variety of ratings, but as the price drops, both the rating itself, and the certainty of that rating also drops. At some point just looking at the price determines the minimal rating -- for example, at $500/night (a hefty sum, to be sure), the star rating will most definitely be a 4 or above, and the review rating at least 4.5.

```{r Regression Analysis}
hotels_ols = lm(price.lead ~ reviews.localizedOverallRating + 
                  comparisonModel.starRating + 
                  factor(neighborhood), 
                data = hotels)

summary(hotels_ols)
```

Running a regression analysis seems also to show that both review rating and star rating are significant factors contributing to the hotel's price (for p<0.01), with a `r str_glue("${format(summary(hotels_ols)$coefficients[2,1], digits = 4)}")` increase in room rates for every review rating point, and a `r str_glue("${format(summary(hotels_ols)$coefficients[3,1], digits = 4)}")` increase for every star.

```{r Regression Analysis Interactions}
hotels_ols_int = lm(price.lead ~ reviews.localizedOverallRating + 
                      comparisonModel.starRating + 
                      reviews.localizedOverallRating * comparisonModel.starRating +
                      factor(neighborhood), 
                    data = hotels)

summary(hotels_ols_int)
```


##Expedia destinations  

Next, we will attempt to look at the destinations stored within Expedia.

```{r Expedia destinations}
destinations = here::here("data/Hotels/Expedia_hotels") %>% 
  list.files(pattern = "*.json", full.names = T) %>%
  map(read_json) %>% 
  map(c("sortAndFilter", "options", "poi", "options")) %>% 
  unlist(recursive = F) %>%  
  map(as_tibble) %>% 
  bind_rows() %>% 
  separate(value, sep = ":", into = c("value", "extrainfo")) %>% 
  separate(value, sep = ",", into = c("latitude", "longitude")) %>% 
  select(-selected) %>% 
  mutate_at(.vars = 2:4, .funs = as.numeric) %>% 
  distinct()

#so far, iterating over all json responses gives the same 20 destinations. Perhaps they are classified by city.

destinations_sf = destinations %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 6668) %>% 
  st_transform(6677)

destinations_sf %>% mutate(colour = case_when(label == "SensÅ-ji Temple" ~ "goldenrod1",
                                              label == "Asakusa Shrine" ~ "goldenrod1",
                                              TRUE ~ "maroon")) %>% 
  tm_shape() +
  tm_dots(col = "colour") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Expedia Destinations")
```

The two destinations Asakusa Shrine and Senso-ji are placed right next to each other. While they are technically two different places, they usually serve as part of the same destination. Since practically every trip made to these locations will always put these destinations within the same trip, one of those destinations should be viewed as a duplicate.

```{r Remove geographically duplicate destinations}
destinations_sf = destinations_sf %>% 
  filter(label != "Asakusa Shrine")

destinations = destinations %>% 
  filter(label != "Asakusa Shrine")
```

```{r Show grid}
tm_shape(yamanote_area_grid) + tm_polygons(alpha = 0.1) +
  tm_shape(destinations_sf) + tm_dots(col = "turquoise", size = 0.05) +
  tm_shape(hotels_sf) + tm_dots(col = "maroon", size = 0.02) +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Geometries of grid, hotels and destinations")
```

In all, these are the objects used for analyses.

##Grid statistics  
In total, `r yamanote_area_grid %>% length()` grid hexagons were created. The hotels are binned into these grids.

```{r Distribution of hotels in grid}
### the _aggr suffix means that the dataset is aggregated.
### (not aggravated) (nor aggroed)
### (whatever)

# Zeroes are inconclusive: take away all zero-price hotels
# hotels_sf = hotels_sf %>% filter(price.strikeout > 0)

hotels_aggr = st_join(hotels_sf, yamanote_area_grid) %>% 
  replace_na(list(grid.id = -1)) %>% 
  st_set_geometry(NULL) %>% 
  group_by(grid.id) %>% 
  summarise(price.lead.average = mean(price.lead),
            price.lead.median = median(price.lead),
            price.lead.sd = sd(price.lead),
            no.hotels = n())

hotels_aggr_sf = yamanote_area_grid %>% 
  left_join(hotels_aggr)

hotels_aggr %>% 
  filter(grid.id > 0) %>% 
  gather("key", "value", -grid.id, -no.hotels) %>% 
  ggplot() +
    geom_boxplot(aes(key, value)) +
  scale_x_discrete(labels = c("Average Price", "Median Price", "Standard Deviation")) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  labs(title = "Distribution of grid prices",
       subtitle = "Average, median prices and standard deviation") +
  coord_flip()
```

This is the distribution of hotels in the grids. The most populous grid has `r max((hotels_aggr %>% filter(grid.id > 0))$no.hotels)`.

##Grid average prices  
```{r Grid average prices}
hotels_aggr_sf %>%
  select(grid.id, everything()) %>% 
  tm_shape() + 
  tm_fill(col = c("price.lead.average", "price.lead.median", "price.lead.sd"), 
          style = "jenks", 
          colorNA = "#CCCCCC", 
          alpha = 0.6) +
  tm_layout(title = "Grid average room price") +
  tm_base
```
We see first that hotels tend to cluster around the main JR routes (Yamanote, Keihin-Tohoku and Chuo lines shown here; the rest mostly parallel these lines). A cluster exists in the lower half of the area, which is served by other subway lines. (specifically, the Tameike area, which is served by Chiyoda, Ginza, Marunouchi, Hanzomon, Yurakucho, Namboku lines.) As mentioned previously, higher priced hotels (this time grouped into grids) tend to be around major stations, and this is very clear in Tokyo.

#Spatial Autocorrelation

Spatial autocorrelation is a measure of how much data points are affected by those around them. In the following sections, I'm going to check the average of hotel prices of each grid's surroundings, and also run a Moran Test. A Moran's Test tells us how much clustering of similar values there are in a spatial dataset.

```{r Spatial Autocorrelation (Neighbours), eval=F, include=F}
hotels_aggr_sp = as(hotels_aggr_sf %>% filter(!is.na(price.lead.average)), "Spatial")

hotels_nb = poly2nb(hotels_aggr_sp)
hotels_wt = nb2listw(hotels_nb, style = "W", zero.policy = T)

hotels_lag = lag.listw(hotels_wt, hotels_aggr_sp$price.lead.average)

ggplot() +
  geom_point(aes(x = hotels_aggr_sp$price.lead.average, y = hotels_lag))
```

```{r Spatial Autocorrelation (Distance)}
hotels_aggr_sp = as(hotels_aggr_sf %>% filter(!is.na(price.lead.average)) %>% st_centroid(), "Spatial")

hotels_nb = dnearneigh(hotels_aggr_sp, 0, 1000, hotels_aggr_sp$grid.id)
hotels_gl = nbdists(hotels_nb, hotels_aggr_sp)

hotels_wt = nb2listw(hotels_nb, glist = hotels_gl, style = "W", zero.policy = T)

hotels_lag = lag.listw(hotels_wt, hotels_aggr_sp$price.lead.average)

ggplot() +
  geom_point(aes(x = hotels_aggr_sp$price.lead.average, y = hotels_lag))
```

There seems to be a correlation between grid average room rates and those of their neighbours, although that correlation seems to quickly deteriorate for pricier grids. It seems that higher-priced hotels (higher priced grids) are more influenced by intrinsic factors rather than locational ones.

##Moran's I
```{r Moran}
moran.test(hotels_aggr_sp$price.lead.average, hotels_wt, zero.policy = T)
```

Here we see that there is a just-strong-enough correlation to suspect some spatial factor.

##Local Moran
*To look at the local amount of clustering*
```{r moran local clustering}
moran_local = localmoran(hotels_aggr_sp$price.lead.average, hotels_wt, zero.policy = T)
hotels_aggr_sp %>% 
  st_as_sf() %>%
  mutate("moran.local" = moran_local[,1]) %>%
  st_set_geometry(NULL) %>% 
  select(grid.id, moran.local) %>% 
  left_join(hotels_aggr_sf, .) %>% 
  tm_shape() +
    tm_fill(col = "moran.local", style = "jenks", palette = "-RdBu", colorNA = "#CCCCCC", alpha = 0.8) +
    tm_layout(title = "LISA (local clustering)") +
  tm_base
```
*Hmm...*

```{r moran local clustering 1500m}
hotels_nb_1500 = dnearneigh(hotels_aggr_sp, 0, 1500, hotels_aggr_sp$grid.id)
hotels_gl_1500 = nbdists(hotels_nb_1500, hotels_aggr_sp)

hotels_wt_1500 = nb2listw(hotels_nb_1500, glist = hotels_gl_1500, style = "W", zero.policy = T)

hotels_lag_1500 = lag.listw(hotels_wt_1500, hotels_aggr_sp$price.lead.average)

ggplot() +
  geom_point(aes(x = hotels_aggr_sp$price.lead.average, y = hotels_lag_1500))

moran.test(hotels_aggr_sp$price.lead.average, hotels_wt_1500, zero.policy = T)

moran_local_1500 = localmoran(hotels_aggr_sp$price.lead.average, hotels_wt_1500, zero.policy = T)
hotels_aggr_sp %>% 
  st_as_sf() %>%
  mutate("moran.local" = moran_local_1500[,1]) %>%
  st_set_geometry(NULL) %>% 
  select(grid.id, moran.local) %>% 
  left_join(hotels_aggr_sf, .) %>% 
  tm_shape() +
    tm_fill(col = "moran.local", style = "jenks", palette = "-RdBu", colorNA = "#CCCCCC", alpha = 0.8) +
    tm_layout(title = "LISA (local clustering)") +
  tm_base
```

Moran's I statistic decreases as we increase the distance to 1500m. There is "negative clustering" appearing as well as "positive clustering." The two highly clustered grids have expanded to 4 in number, but their values have dropped drastically.

#Accessibilities  
```{r Accessibility of grids, eval=F}
# otp_path_folder = here::here("data/OpenTripPlanner/")
# otp_path = file.path(otp_path_folder,"otp-1.3.0-shaded.jar")
# otp_path_data = otp_path_folder
# otp_setup(otp = otp_path, 
#           dir = otp_path_data, 
#           memory = 6192, 
#           router = "Tokyo")
otpcon = otp_connect() #May take a while to load

from = yamanote_area_grid %>% 
  st_centroid() %>% 
  st_transform(4326)
to = destinations_sf %>% 
  st_transform(4326)

fromPlace = from %>% st_coordinates() %>% as_tibble() %>% mutate(fromID = from$grid.id) %>% slice(rep(1:n(), times = nrow(to)))
toPlace = to %>% st_coordinates() %>% as_tibble() %>% mutate(toID = to$extrainfo) %>% slice(rep(1:n(), each = nrow(from))) 

pb = progress_estimated(nrow(toPlace), 5)

get_itinerary = function(fromY, fromX, toY, toX, fromID, toID) {
  if(!is.null(pb)) pb$tick()$print()
  from_ = str_glue("{fromY},{fromX}")
  to_   = str_glue("{toY},{toX}")
  
  response = GET(url = "http://localhost:8080",
                 path = "otp/routers/Tokyo/plan",
                 query = list(fromPlace = from_,
                              toPlace   = to_,
                              time      = "6:00pm",
                              date      = "2019-11-06",
                              maxTransfers = 5,
                              numItineraries = 1)) %>% 
    content()
  
  if(is.null(response$plan)) return(NULL)
  
  response$plan$itineraries %>% 
    map(as_tibble) %>%  
    bind_rows(.id = "option") %>%
    mutate(startTime = as.POSIXct(startTime/1000, origin = "1970-01-01"),
           endTime   = as.POSIXct(endTime/1000,   origin = "1970-01-01")) %>%
    mutate(leg.distance = map(legs, "distance") %>% unlist(),
           leg.mode     = map(legs, "mode") %>% unlist(),
           leg.routeId  = map(legs, "routeId", .default = NA) %>% unlist(),
           leg.from     = map(legs, "from"),
           leg.to       = map(legs, "to")) %>%
    mutate(leg.from.stopId = map_chr(leg.from, "stopId", .default = "Origin"),
           leg.to.stopId   = map_chr(leg.to,   "stopId", .default = "Destination"),
           leg.from.stopCode = map_chr(leg.from, "stopCode", .default = "none"),
           leg.to.stopCode   = map_chr(leg.to,   "stopCode", .default = "none")) %>% 
    group_by(option) %>% 
    mutate(leg = row_number()) %>% 
    ungroup() %>% 
    mutate(fromID = fromID,
           toID = toID)
}

grid_routes = pmap_dfr(list(fromX = fromPlace$X,
                            fromY = fromPlace$Y,
                            toX   = toPlace$X,
                            toY   = toPlace$Y,
                            fromID= fromPlace$fromID,
                            toID  = toPlace$toID),
                            get_itinerary)
pb$stop()

# test = otp_plan(otpcon = otpcon,
#                        fromPlace = from %>% slice(1),
#                        toPlace = to %>% slice(1),
#                        fromID = from$grid.id[1] %>% as.character(),
#                        toID = to$extrainfo[1] %>% as.character(),
#                        mode = c("WALK", "TRANSIT"),
#                        date_time = as.POSIXct(strptime("2019-07-23 17:00", "%Y-%m-%d %H:%M")),
#                        get_geometry = T,
#                        numItineraries = 1,
#                        ncores = 4)

# Fares
fare_response = GET(url = "https://api-tokyochallenge.odpt.org",
                    path = "api/v4/odpt:RailwayFare.json",
                    query = list("acl:consumerKey" = apikey))
fare_content = fare_response %>% content()
fares = tibble(from.station = map_chr(fare_content, "odpt:fromStation", .default = NA),
               to.station   = map_chr(fare_content, "odpt:toStation",   .default = NA),
               ticket.fare  = map_dbl(fare_content, "odpt:ticketFare",  .default = NA)) %>% 
  mutate_at(vars(-ticket.fare), ~map_chr(.x, ~str_split(.x, ":")[[1]][2]))


# getFare = function(fromStation, toStation) {
#   response = GET(url = "https://api-tokyochallenge.odpt.org",
#                path = "api/v4/odpt:RailwayFare",
#                query = list("acl:consumerKey" = apikey,
#                             "odpt:fromStation" = "odpt.Station:Toei.Oedo.Ryogoku",
#                             "odpt:toStation" = "odpt.Station:Toei.Asakusa.Asakusa"))
#   content = response %>% content()
#   if(length(content) < 1)
#     return(NA)
#   else
#     return(content[[1]]$`odpt:ticketFare`)
# }

getFare = function(agency, fromStation, toStation, distance, yamanote_only){
  if(agency == "JR-East") {
    # The total distance given is straight-line,
    # we are assuming that is a good estimation for
    # the actual distance
    
    # Max distance from a sample dataset is 42.5km
    # Lay out prices until 50.0km
    if(yamanote_only) {
      currentFare = case_when(distance <= 3000   ~ 140,
                              distance <= 6000   ~ 160,
                              distance <= 10000  ~ 170,
                              distance <= 15000  ~ 200,
                              distance <= 20000  ~ 260)
    } else {
      # Assume inside special area
      currentFare = case_when(distance <= 3000   ~ 140,
                              distance <= 6000   ~ 160,
                              distance <= 10000  ~ 170,
                              distance <= 15000  ~ 220,
                              distance <= 20000  ~ 310,
                              distance <= 25000  ~ 390,
                              distance <= 30000  ~ 470,
                              distance <= 35000  ~ 550,
                              distance <= 40000  ~ 640,
                              distance <= 45000  ~ 720,
                              TRUE               ~ 800)
    }
  } else if (agency %in% c("Keikyu",
                           "Keio",
                           "Keisei",
                           "Odakyu",
                           "Seibu",
                           "Tobu",
                           "Toei",
                           "TokyoMetro",
                           "Tokyu",
                           "TWR",
                           "Yurikamome")) {
    # These can be fetched from the fares dataset
    # Assume that there is only one entry
    currentFare = filter(fares, 
                         from.station == fromStation, 
                         to.station == toStation)$ticket.fare[1]
  } else {
    # Something is wrong: report
    warning(str_glue("Fare for {fromStation} to {toStation} has a problem. Returning NA"))
    currentFare = NA
  }
  
  return(currentFare)
}
getFareFromLegs = function(legs) {
  fare = 0
  previousAgency = ""
  yamanote_only = F
  distance = 0
  boardingStation = ""
  alightingStation = ""
  for(i in 1:length(legs)) {
    leg = legs[[i]]
    
    if(leg$mode == "RAIL") {
      # taking the train, take note of distance travelled and 
      # agency
      currentStation = leg$from$stopId %>% str_extract("(?<=\\d:).*$")
      currentAgency = currentStation %>% str_split("\\.") %>% `[[`(1) %>% `[`(1)
      currentLine = currentStation %>% str_split("\\.") %>% `[[`(1)%>% `[`(2)
      # Don't set the boarding or alighting station here -- we need that information
      # From the last leg once the code detects a transfer
      # and that transfer can happen after a WALK leg
      
      # This line will be skipped if yamanote is the only journey on the leg
      if(currentLine != "Yamanote") yamanote_only = F
      
      if(currentAgency == previousAgency || previousAgency == "") {
        # Don't do anything; just take note of distance
        distance = distance + leg$distance
        
      } else {
        currentFare = getFare(previousAgency, boardingStation, alightingStation, distance, yamanote_only)
        
        #Add the current fare to the total fare
        fare = fare + currentFare
        
        #Reset the previous leg's boarding station
        boardingStation = ""
        
        #restart recording distance (including this trip!)
        distance = leg$distance
      }
      
      # Now that all the processing is done, we can refresh the boarding and alighting station
      if(boardingStation == "") {
        # Start of a trip section (either first train or after interchange)
        boardingStation = currentStation
        
        # And if it is the Yamanote line, prepare for Yamanote line-only fare
        if(currentLine == "Yamanote") yamanote_only = T
      }
      alightingStation = leg$to$stopId %>% str_extract("(?<=\\d:).*$")
      previousAgency = currentAgency
    }
    
    if(leg$mode == "WALK" & i == length(legs)) {
      # Last leg; add the fare for the last trip
      currentFare = getFare(previousAgency, boardingStation, alightingStation, distance, yamanote_only)
      fare = fare + currentFare
    }
  }
  
  return(fare)
}



grid_routes_all_vars = grid_routes %>% 
  mutate(leg.from.station = str_extract(leg.from.stopId, "(?<=\\d:).*$"),
         leg.to.station   = str_extract(leg.to.stopId,   "(?<=\\d:).*$")) %>% 
  mutate(leg.from.agency = map_chr(leg.from.station, ~str_split(.x, "\\.")[[1]][1]),
         leg.to.agency   = map_chr(leg.to.station,   ~str_split(.x, "\\.")[[1]][1])) %>% 
  left_join(fares, by = c("leg.from.station" = "from.station", "leg.to.station" = "to.station")) %>% 
  mutate(ticket.fare = case_when(leg.mode != "RAIL" ~ 0,
                                 TRUE ~ ticket.fare)) %>% 
  rename(leg.fare = ticket.fare) %>% 
  group_by(fromID, toID, option) %>% 
  summarise(duration = first(duration),
            startTime = first(startTime),
            endTime = first(endTime),
            walkTime = first(walkTime),
            transitTime = first(transitTime),
            waitingTime = first(waitingTime),
            walkDistance = first(walkDistance),
            walkLimitExceeded = first(walkLimitExceeded),
            transfers = first(transfers),
            distance = sum(leg.distance),
            fare = getFareFromLegs(legs))
```

```{r Accessibility of grids rds, include=F}
grid_routes_all_vars = read_rds(here::here("data/grid_routes_all_vars.rds"))
grid_routes = grid_routes_all_vars %>% 
  select(fromPlace = fromID, toPlace = toID, duration,
         option, transfers, distance, fare)

from = read_rds(here::here("data/from.rds"))
to = read_rds(here::here("data/to.rds"))
fromPlace = read_rds(here::here("data/fromPlace.rds"))
toPlace = read_rds(here::here("data/toPlace.rds"))
```

```{r Investigate routes}
# missing destinations/grids: which?

grid_missing = from %>% 
  mutate(included = grid.id %in% grid_routes$fromPlace) %>% 
  filter(!included)

destinations_missing = to %>% 
  mutate(included = extrainfo %in% grid_routes$toPlace) %>% 
  filter(!included)

tm_shape(grid_missing) + tm_dots(col = "maroon", title = "Missing grids") +
  tm_shape(destinations_missing) + tm_dots(col = "turquoise", title = "Missing destinations") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.4) +
  tm_layout(title = "Missing geometries")
```

```{r Tracemap, eval=F, include=F}
### dataisbeautiful
trace_routes = grid_routes %>% 
  st_zm() %>% 
  group_by(fromPlace, toPlace) %>% 
  summarise()

tm_shape(trace_routes) +
  tm_lines(lwd = 1.25, alpha = 0.07, col = "white") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.2) +
  tm_layout(bg.color = "black", title = "Tracemap of routes from grid centres to destinations")
```

```{r Average times}
grid_aggr_time = grid_routes %>% 
  # st_set_geometry(NULL) %>% 
  # group_by(fromPlace, toPlace) %>% 
  # summarise(duration = first(duration)) %>% 
  group_by(fromPlace) %>%
  summarise(duration = mean(duration)/60) %>% 
  mutate(fromPlace = as.integer(fromPlace)) %>% 
  right_join(yamanote_area_grid, by = c("fromPlace" = "grid.id")) %>% 
  select(duration, everything()) %>% 
  st_as_sf()

tm_shape(grid_aggr_time) +
  tm_fill(col = "duration", style = "jenks", n = 10, palette = "-inferno", alpha = 0.7) +
  tm_layout(title = "Accessibility of grid-centres by mean time taken") +
  tm_base
```
very subtle patterns can be seen here. For example, Tokyo has a high level of accessibility, and this high level emanates from Tokyo through the two main JR line-clusters: the Tokaido Line-Tohoku Line cluster (Blue Line; Keihin-Tohoku; N-S), and the Chuo Line cluster (Orange line; Chuo; E-W). Some grids have very good accessibility because one of the destinations is in the grid. This shows that the averaging method may be too biased towards grids which are close to one attraction.

```{r Average ticket prices}
# This was created with the new implementation of get_itinerary, which has already
# output a summarised version (only option 1), and doesn't contain geometry.

grid_aggr_fare = grid_routes %>% 
  group_by(fromPlace) %>% 
  summarise(fare = mean(fare)) %>% 
  mutate(fromPlace = as.integer(fromPlace)) %>% 
  right_join(yamanote_area_grid, by = c("fromPlace" = "grid.id")) %>% 
  select(fare, everything()) %>% 
  st_as_sf()

tm_shape(grid_aggr_fare) +
  tm_fill(col = "fare", style = "jenks", n = 10, palette = "-inferno", alpha = 0.7) +
  tm_layout(title = "Accessibility of grid-centres by mean fare") +
  tm_base
```
*A large chunk of fares is unavailable for the middle section, and most worryingly around the Shinjuku area. Need to check implementation.*

```{r Average SLD}
# straight-line distance

grid_aggr_dist = yamanote_area_grid %>% 
  mutate(dist.average = st_distance(., destinations_sf) %>% rowMeans())

tm_shape(grid_aggr_dist) +
  tm_fill(col = "dist.average", style = "jenks", n = 10, palette = "-inferno", alpha = 0.7) +
  tm_layout(title = "Accessibility of grid-centres by mean straight-line distance") +
  tm_base
```
On the other hand, this is the pattern which shows up when the accessibilities are calculated by the average straight-line distance from the grid centres to each of the destinations. The patterns are much smoother and don't show the level of specificity we see in the previous plot. Yet, we assume that this is a good estimation!

Since the idea of using straight-line distance stems from the hypothesis that doing so is a good estimation of the actual distance/time taken for the traveller to reach each destination, we can derive the amount of over- and under-estimation for each grid. To do that, the distance mapping needs to be first turned into a time mapping. This is done by dividing the distance by the average speed of all trips from one grid centre.

```{r Average speed, Average time, Difference in estimation}
grid_aggr_speed = grid_routes %>% 
  # st_set_geometry(NULL) %>% 
  group_by(fromPlace, toPlace) %>%
  mutate(speed = distance/(duration/60)) %>% 
  group_by(fromPlace) %>% 
  summarise(speed = mean(speed)) %>% 
  mutate(fromPlace = as.integer(fromPlace)) %>% 
  right_join(yamanote_area_grid, by = c("fromPlace" = "grid.id")) %>% 
  st_as_sf()

grid_aggr_time_sdl = grid_aggr_dist %>% 
  st_set_geometry(NULL) %>% 
  left_join(grid_aggr_speed, by = c("grid.id" = "fromPlace")) %>% 
  mutate(duration.sdl = dist.average/speed) %>% 
  st_as_sf()

grid_aggr_estimation_diff = grid_aggr_time %>% 
  left_join(grid_aggr_time_sdl %>% st_set_geometry(NULL), by = c("fromPlace" = "grid.id")) %>% 
  mutate(duration.diff = duration.sdl - duration)

grid_aggr_estimation_diff %>% 
  select(duration.diff, everything()) %>% 
  tm_shape() +
    tm_fill(col = "duration.diff", style = "jenks", n = 6, palette = "RdBu", alpha = 0.7) +
    tm_base
```
The map above shows the degree to which using straight-line distance underestimates the time taken to travel to the destinations. The major stations seem to fare better, at a 10-minute underestimation. Some areas, however, have grossly underestimated timings -- up to half an hour.

##Including accessibility metrics in the regression  
Next, I will attempt to include (separately) the two accessibility metrics to the regression model. A regression model for the gridded data must be produced first:

```{r Grid-based regression}
hotels_aggr_all = hotels_sf %>% st_join(yamanote_area_grid) %>% 
  st_set_geometry(NULL) %>% 
  group_by(grid.id) %>% 
  summarise_at(vars(price.lead, 
                    reviews.localizedOverallRating, 
                    comparisonModel.starRating),
               mean) %>% 
  left_join(grid_aggr_estimation_diff %>% st_set_geometry(NULL), by = c("grid.id" = "fromPlace")) %>% 
  left_join(grid_aggr_fare %>% st_set_geometry(NULL), by = c("grid.id" = "fromPlace"))

lm(price.lead ~ reviews.localizedOverallRating + 
     comparisonModel.starRating +
     reviews.localizedOverallRating * comparisonModel.starRating,
   data = hotels_aggr_all) %>% 
  summary()
```

Next, adding average straight-line distance as a factor:
```{r Grid-based regression with SLD}
lm(price.lead ~ reviews.localizedOverallRating + 
    comparisonModel.starRating +
    reviews.localizedOverallRating * comparisonModel.starRating +
    dist.average,
  data = hotels_aggr_all) %>% 
  summary()
```

There is not much that the average distance can explain. When using average time taken (of shortest network paths)
```{r Grid-based regression with network}
lm(price.lead ~ reviews.localizedOverallRating + 
    comparisonModel.starRating +
    reviews.localizedOverallRating * comparisonModel.starRating +
    duration,
  data = hotels_aggr_all) %>% 
  summary()
```
Although the additional factor isn't significant, the model does improve slightly more than for the straight-line distance case.

```{r Grid-based regression on time-SLD}
lm(price.lead ~ reviews.localizedOverallRating + 
    comparisonModel.starRating +
    reviews.localizedOverallRating * comparisonModel.starRating +
    duration.sdl,
  data = hotels_aggr_all) %>% 
  summary()
```
Including the average speed to turn the SLD into a straight-line "time" metric improves the correlation *just* slightly.

```{r Grid-based regression with network - Interaction with review rating}
lm(price.lead ~ reviews.localizedOverallRating +
     comparisonModel.starRating +
     duration +
     reviews.localizedOverallRating * comparisonModel.starRating +
     duration * reviews.localizedOverallRating,
   data = hotels_aggr_all) %>% 
  summary()
```

```{r Grid-based regression with SLD - Interaction with review rating}
lm(price.lead ~ reviews.localizedOverallRating +
     comparisonModel.starRating +
     dist.average +
     reviews.localizedOverallRating * comparisonModel.starRating +
     dist.average * reviews.localizedOverallRating,
   data = hotels_aggr_all) %>% 
  summary()
```
However, when the accessibility metrics are presumed to interact with the review rating, the significance of those factors become much more significant. Surprisingly using SLD actually gives an even better result, having a p-value of <0.01 (0.007). The average-time metric has a slightly worse result, at 0.016.

```{r}
lm(price.lead ~ reviews.localizedOverallRating +
     comparisonModel.starRating +
     duration * reviews.localizedOverallRating * fare,
   data = hotels_aggr_all) %>% 
  summary()

#R^2 0.7411 adj .7115
```
If we add fares into the model, and interact it with both average time and review rating, the model improves insofar as the R-squared metrics increase substantially, to 0.74. The significance of locational factors also improves drastically (to 0.5% ~ 0.1% p-values). The two factors which don't meet the <1% p-value significance are duration-fare -- perhaps it shows that different lines operate at different speeds, and so the time taken (for the same price, as price is mainly controlled by distance) is not the same for every line -- and review rating-duration-fare.


```{r Grid-based correlations between factors}
gg_collm = function(data, mapping, ...) {
  p = ggplot(data = data, mapping = mapping) +
    geom_point() +
    geom_smooth(method = lm, fill = "blue", colour = "blue", ...)
  p
}

hotels_aggr_all %>% 
  select(price.lead, 
         reviews.localizedOverallRating,
         comparisonModel.starRating,
         duration,
         dist.average,
         fare) %>% 
  ggpairs(lower = list(continuous = gg_collm))
```

```{r Grid-based regression - Only star and accessibility}
lm(price.lead ~ comparisonModel.starRating +
     dist.average * duration,
   data = hotels_aggr_all) %>% 
  summary()
```

