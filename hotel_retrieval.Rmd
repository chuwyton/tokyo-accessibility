---
title: "Analysing Hotel Prices"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

ggmap was used in this exploratory script.
CRS: Japanese Geodetic Datum 2011 (54N). This encompasses Tokyo and is the most precise. EPSG: 6691

```{r Setup, include=F}
library(tidyverse)
library(jsonlite)
library(sf)
library(sp)
library(spdep)
library(ggmap)
library(tmap) #for exploration
library(GGally) # for pairs, mostly
library(osmdata)
library(opentripplanner)
library(httr)
library(xml2)
# library(rvest)
# library(RSelenium)

tmap_mode("view")
```

```{r Prefix Suffix definitions, include=F}
######## SUFFIXES
### _aggr: the dataset that this variable points to is aggregated.
```

#Non-Spatial Analysis  

We will first look at non-spatial analysis of hotels in Tokyo.

```{r Scrape hotels}
#6~7 Nov, 1 adult, 1 room
#build fetch

url = "https://www.expedia.com/"
path = "hotel-shop/api/1/en_US/hotels"
query = c(accessibility = "",
          amenities = "",
          destination = "Tokyo (and vicinity), Japan",
          endDate = "2019-11-07",
          latLong = "35.675,139.76",
          lodging = "",
          paymentType = "",
          price = "",
          regionId = "179900",
          sort = "recommended",
          startDate = "2019-11-06",
          travelerType = "",
          userRewards = "true",
          localDateFormat = "M/d/yyyy",
          priceFilterBuckets = "",
          count = "2000",
          startingIndex = "1",
          adults = "1")

response = GET(url = url,
               query = query,
               add_headers(.headers = c("accept-encoding" = "gzip, deflate, br",
                      "accept-language" = "en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6,ja;q=0.5",
                      "x-remote-addr" = "103.24.77.51, 96.17.180.174, 125.56.219.90, 10.7.22.119, 52.220.191.232",
                      "cookie" = "tpid=v.1,1; iEAPID=0; currency=USD; linfo=v.4,|0|0|255|1|0||||||||1033|0|0||0|0|0|-1|-1; HMS=8eb7de8a-4f9c-48e9-af6c-37569e4953ca; DUAID=66cca9d4-baf2-410f-8365-6288c866691e; MC1=GUID=66cca9d4baf2410f83656288c866691e; ak_bmsc=2CE9B6A63AC897D59852F5211CEBAEF06011B4AE6A60000062542C5DC32A1816~plIdWDwJQecFy6mA/nhsX02W/Mj4berGkhXPNqh/2ATQLmynxQHYAlXl7SCFZzn0ETD3EbKru9s4vkAgCfSq2EF4el/2JdgH8j85jGXsCb/gBrI90XKgK8XTdG7DI314zn7kyKa7Uvnp7FJvRhF7/cTN/wkt8vD/r4sBbwY1JNXmfJCSgB16+y9W/JgzXNOnK23paCqQ5RNrMUY3OH9+EPWp3wxvOClusQVT/NMMp2AKA=; AMCVS_C00802BE5330A8350A490D4C%40AdobeOrg=1; aspp=v.1,0|||||||||||||; stop_mobi=yes; JSESSIONID=7D73FBF9F8078EE5B8F5BCD914A66378; s_ecid=MCMID%7C33131617227363293851514339830081388369; AMCV_C00802BE5330A8350A490D4C%40AdobeOrg=1406116232%7CMCIDTS%7C18093%7CMCMID%7C33131617227363293851514339830081388369%7CMCAAMLH-1563791070%7C3%7CMCAAMB-1563791070%7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y%7CMCOPTOUT-1563193470s%7CNONE%7CMCAID%7CNONE%7CvVersion%7C2.5.0; s_cc=true; CONSENTMGR=ts:1563186271727%7Cconsent:true; AB_Test_TripAdvisor=A; qualtrics_sample=false; rlt_marketing_code_cookie=; qualtrics_SI_sample=false; ipsnf3=v.3|us|1|753|chandler; JSESSION=c50a1783-393c-46ee-8ab0-db868fc44635; intent_media_prefs=; _gcl_au=1.1.1825130036.1563186272; __gads=ID=2b5a47aa8ae5e1da:T=1563186275:S=ALNI_MaLqKpR9M90UcseTvO2fM9DRd2VIg; im_snid=4c52d204-9959-4169-b870-7eed0cb82b28; _ga=GA1.2.615676407.1563186272; _gid=GA1.2.1463963763.1563186273; _gat_gtag_UA_35711341_2=1; _fbp=fb.1.1563186272743.1212476019; _tq_id.TV-721872-1.7ec4=e9fe8c18af11ea4e.1563186273.0.1563186273..; xdid=340fe610-5e53-41ff-962a-aba253adeb0d|1563186277|expedia.com; x-CGP-exp-30353=3; x-CGP-exp-15795=2; x-CGP-exp-28702=0; pwa_csrf=b8933d54-eebb-4ddc-a92c-33e04a147603|6BQK3yOPKGEw5Y3yfS25QxhjzV3aP_DkcczvTFm13FjfGtca9c5X54oK6qyptC6FYqM0gnUSPy16dBgZ3LaCEw; x-cgp-exp=27461.79023.pwa; x-CGP-exp-27461=1; s_ppn=page.Hotel-Search; utag_main=v_id:016bf52995f30015c9989cde72f303073001806b00bd0$_sn:1$_ss:0$_pn:2%3Bexp-session$_st:1563188088847$ses_id:1563186271731%3Bexp-session; cesc=%7B%22visitNumber%22%3A%5B%221%22%2C1563186274123%5D%2C%22cidVisit%22%3A%5B%22Brand.DTI%22%2C1563186292494%5D%2C%22entryPage%22%3A%5B%22Homepage%22%2C1563186292494%5D%2C%22cid%22%3A%5B%22Brand.DTI%22%2C1563186274123%5D%7D; s_ppvl=Homepage%2C24%2C24%2C969%2C1364%2C969%2C1920%2C1080%2C1%2CP; _ctz_plugin_opt=0; s_ppv=Homepage%2C100%2C24%2C9675%2C1364%2C969%2C1920%2C1080%2C1%2CP; IM_eu_freq_cap=Y",
                      "x-user-state" = "anonymous",
                      "x-user-agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36",
                      "user-agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36",
                      "content-type" = "application/json",
                      "accept" = "application/json",
                      "referer" = "https://www.expedia.com/Hotel-Search?destination=Tokyo%2C+Japan&latLong=35.675%2C139.76&regionId=179900&startDate=11%2F06%2F2019&endDate=11%2F07%2F2019&rooms=1&adults=1",
                      "authority" = "www.expedia.com",
                      "x-mc1-guid" = "66cca9d4-baf2-410f-8365-6288c866691e",
                      "x-api-token" = "83b54f81b7055087cc1096b4bbbbeeaf868dd080")))
```


```{r Get hotels, eval=F}
#NEW search condition: 6 - 7 November 2019, 1 adult 1 room.

get_hotels = function(path) {
  test = read_json(path)$hotels %>% keep(~.x$type == "HotelViewModel")
  test_tibble = tibble(hotelId = map(test, "hotelId") %>% unlist(),
                       hotelName = map(test, "hotelName") %>% unlist(),
                       #shortlistModel = map(test, "shortlistModel"),
                       displayPrice = map(test, "displayPrice") %>% unlist(),
                       latitude = map(test, "latitude") %>% unlist(),
                       longitude = map(test, "longitude") %>% unlist(),
                       hotelFlags = map(test, "hotelFlags"),
                       price = map(test, "price"),
                       neighborhood = map(test, "neighborhood") %>% unlist(),
                       reviews = map(test, "reviews"),
                       resultType = map(test, "resultType") %>% unlist(),
                       comparisonModel = map(test, "comparisonModel")) %>% 
    drop_na() %>% 
    mutate(price.lead = map(price, "lead") %>% unlist(),
           price.strikeout = map(price, "strikeOut", .default = NA_character_) %>% unlist(),
           reviews.localizedOverallRating = map(reviews, "localizedOverallRating") %>% unlist(),
           reviews.localizedCount = map(reviews, "localizedCount") %>% unlist(),
           reviews.superlative = map(reviews, "superlative", .default = NA_character_) %>% unlist(),
           comparisonModel.amenities = map(comparisonModel, "amenities"),
           comparisonModel.starRating = map(comparisonModel, "starRating") %>% unlist()) %>% 
    mutate(displayPrice = parse_number(displayPrice),
           latitude = parse_number(latitude),
           longitude = parse_number(longitude),
           price.lead = parse_number(price.lead),
           price.strikeout = parse_number(price.strikeout),
           reviews.localizedOverallRating = parse_number(reviews.localizedOverallRating),
           reviews.localizedCount = parse_number(reviews.localizedCount),
           reviews.superlative = parse_factor(reviews.superlative,
                                              levels = c(NA_character_, "Good", "Very Good", "Excellent", "Wonderful", "Exceptional"),
                                              ordered = T)) %>% 
    mutate(price.strikeout = if_else(is.na(price.strikeout), price.lead, price.strikeout)) %>% 
    select(hotelId, 
           hotelName, 
           neighborhood, 
           price.lead, 
           price.strikeout,
           reviews.superlative,
           reviews.localizedOverallRating,
           reviews.localizedCount,
           comparisonModel.starRating,
           latitude,
           longitude,
           hotelFlags, 
           comparisonModel.amenities,
           comparisonModel)

  return(test_tibble)
}

# tb = get_hotels("data/Hotels/Expedia_hotels_150.json")

assumedLocation = here::here("data/Hotels/Expedia_hotels.zip")
if(file.exists(assumedLocation)){
  local_path = assumedLocation
} else {
  local_path = choose.files(default = here::here(), caption = "Select zip folder containing Expedia hotel jsons", multi = F)
}

local_path %>% unzip(exdir = here::here("data/Hotels/Expedia_hotels"))
hotels = here::here("data/Hotels/Expedia_hotels") %>% list.files(pattern = "*.json", full.names = T) %>% map(get_hotels) %>% bind_rows()
```

```{r Get hotels rds}
hotels = read_rds(here::here("data/hotels.rds"))
```

##Hexagonal grids

Before moving on, I'll create the boundary for my research, and cut it into grids. This allows us to scope the hotels down to only the specific area we're looking at.

```{r Get grid, eval=F}
q = getbb("Tokyo") %>%
  opq(timeout = 60) %>%
  add_osm_feature("route", "train") %>%
  add_osm_feature("name:en", "JR Yamanote Line (Outer)")

yamanote = osmdata_sf(q)
yamanote_area = yamanote$osm_lines %>%
  st_transform(6677) %>% 
  st_union() %>% 
  st_convex_hull() %>% 
  st_buffer(1000)
yamanote_area_grid = yamanote_area %>% 
  st_make_grid(square = F, cellsize = 500) %>% 
  st_sf() %>% 
  rowid_to_column("grid.id")
```

```{r Get grid rds}
yamanote_area_grid = read_rds(here::here("data/yamanote_area_grid.rds"))
```

```{r hotel inclusion}

# Check inclusion
hotels_sf = hotels %>% 
  select(hotelName, everything()) %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 6668) %>% 
  st_transform(6677)

hotels_sf = hotels_sf %>% 
  mutate(within.boundary = st_within(., yamanote_area_grid) %>% lengths()) %>% 
  mutate(within.boundary = ifelse(within.boundary == 0, "No", "Yes"))

tm_shape(yamanote_area_grid) +
  tm_fill(col = "grey", alpha = 0.4) +
  tm_shape(hotels_sf) +
  tm_dots(col = "within.boundary", title="Falls within boundary") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Inclusion of hotels")
```

Altogether, `r nrow(filter(hotels_sf, within.boundary == "Yes"))` out of `r nrow(hotels_sf)` hotels fall in the central area.

```{r Prune data}
#...to include only those in the yamanote region.

hotels_sf = hotels_sf %>% filter(within.boundary == "Yes")
hotels = hotels_sf %>% st_set_geometry(NULL)
```

With the hotels which fall outside of our area of research put aside, we can now look at the various distributions of the remaining hotels.

```{r Quick check: general distribution}
hotels %>% select(reviews.localizedOverallRating, comparisonModel.starRating) %>% 
  gather() %>% 
  ggplot(aes(value)) +
  geom_bar(stat = "count") +
  facet_wrap(~key, scales = "free_x", labeller = labeller(key = c(reviews.localizedOverallRating = "Overall rating",
                                                                  comparisonModel.starRating = "Star rating"))) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        axis.title.x = element_blank()) +
  labs(title = "General distribution of hotels",
       subtitle = "Overall rating, Star rating",
       y = "Number of hotels")

hotels %>% select(reviews.localizedOverallRating, comparisonModel.starRating, price.lead, price.strikeout) %>% 
  gather(key = "key", value = "value", -price.lead, -price.strikeout) %>% 
  gather(key = "price.type", value = "price", -key, -value) %>% 
  ggplot(aes(x = value, y = price, group = value)) +
  geom_boxplot(position = "dodge2") +
  facet_grid(price.type~key, 
             scales = "free_x", 
             labeller = labeller(key = c(reviews.localizedOverallRating = "Overall rating",
                                         comparisonModel.starRating = "Star rating",
                                         price.lead = "Lead price",
                                         price.strikeout = "Strikeout price"))) +
  theme_minimal() +
  theme(axis.title.x = element_blank()) +
  labs(title = "Price distribution of hotels",
       subtitle = "By Overall rating, Star rating",
       y = "Price")
```

There are two types of prices shown in Expedia: the "lead" price and the "strikeout" price. The strikeout price is not always present, but if it is, it is always more than the lead price. the strikeout price is then displayed in a grey colour and "struck through", indicating that the lead price is a "special" price to the customer. Expedia explains that this price is "the third highest price for this room type at this property (with the same length of stay and cancellation policy) that customers have found on our site during a 30 day window" around the selected check-in date.

This leads to some differences in the boxplots shown below, but nothing that would lead to drastic changes in regression analyses. For convenience the lead price will be used.

We definitely see an upward trend in room prices for star rating. As for the overall rating, the prices peak at 4.7, and then go down, meaning that hotels with a rating higher than 4.7 actually enjoy a lowesr room price. This is probably because customers take the price into account when rating hotels.

```{r Quick check: general distribution 2}
hotels %>% group_by(neighborhood) %>% 
  summarise(count = n()) %>% 
  ggplot(aes(x = reorder(neighborhood, -count), y = count)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "General distribution of hotels",
       subtitle = "Neighbourhood",
       y = "Number of Hotels", x = "Neighbourhood") +
  coord_flip()

hotels %>%  
  ggplot(aes(x = fct_reorder(neighborhood, price.lead), y = price.lead)) +
    geom_boxplot() +
    theme_minimal() +
    labs(title = "General price distribution of hotels",
         subtitle = "by Area",
         caption = "*unit: S$/person/night",
         y = "Price", x = "Neighbourhood") +
  coord_flip()
```

*In general, most hotels are classified under "Tokyo". Thus, Tokyo also has the larges range of prices. I'm not sure if explaining the variances in areas makes any sense, because the areas themselves seem to be quite poorly classified to begin with.*

```{r Quick check: spatial distr}
hotels_sf %>% 
  tm_shape() +
  tm_dots(col = "price.lead", title = "Price", style = "jenks") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Price distribution of hotels")

# get_map("Tokyo") %>% ggmap() +
#   geom_sf(data = hotels_sf)
```

There is a number of hotels which follow the trend that hotels closer to large stations (see Shibuya, Shinjuku) are pricier. Otherwise, a good mix exists.

```{r Quick check: spatial distr nbh}
hotels_sf %>% 
  tm_shape() + 
  tm_dots(col = "neighborhood") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Neighborhood distribution of hotels")
```

*This just shows how the hotels are grouped according to Expedia.*

```{r Quick check: pairs}
hotels %>% 
  ggpairs(columns = c("price.lead", 
                      "reviews.localizedOverallRating",
                      "comparisonModel.starRating"),
          mapping = aes(alpha = 0.4))
```

These are paired plots for price (strikeout -- un-discounted prices), overall rating, and star rating. There is a good (0.6) correlation between the price and the star rating, and a slightly-less good correlation between review rating and star rating. As demonstrated in the boxplots, hotels of all prices can exist along a variety of ratings, but as the price drops, both the rating itself, and the certainty of that rating also drops. At some point just looking at the price determines the minimal rating -- for example, at $500/night (a hefty sum, to be sure), the star rating will most definitely be a 4 or above, and the review rating at least 4.5.

```{r Regression Analysis}
hotels_ols = lm(price.lead ~ reviews.localizedOverallRating + 
                  comparisonModel.starRating + 
                  factor(neighborhood), 
                data = hotels)

summary(hotels_ols)
```

Running a regression analysis seems also to show that both review rating and star rating are significant factors contributing to the hotel's price (for p<0.01), with a `r str_glue("${format(summary(hotels_ols)$coefficients[2,1], digits = 4)}")` increase in room rates for every review rating point, and a `r str_glue("${format(summary(hotels_ols)$coefficients[3,1], digits = 4)}")` increase for every star.

```{r Regression Analysis Interactions}
hotels_ols_int = lm(price.lead ~ reviews.localizedOverallRating + 
                      comparisonModel.starRating + 
                      reviews.localizedOverallRating * comparisonModel.starRating +
                      factor(neighborhood), 
                    data = hotels)

summary(hotels_ols_int)
```


##Expedia destinations  

Next, we will attempt to look at the destinations stored within Expedia.

```{r Expedia destinations}
destinations = here::here("data/Hotels/Expedia_hotels") %>% 
  list.files(pattern = "*.json", full.names = T) %>%
  map(read_json) %>% 
  map(c("sortAndFilter", "options", "poi", "options")) %>% 
  unlist(recursive = F) %>%  
  map(as_tibble) %>% 
  bind_rows() %>% 
  separate(value, sep = ":", into = c("value", "extrainfo")) %>% 
  separate(value, sep = ",", into = c("latitude", "longitude")) %>% 
  select(-selected) %>% 
  mutate_at(.vars = 2:4, .funs = as.numeric) %>% 
  distinct()

#so far, iterating over all json responses gives the same 20 destinations. Perhaps they are classified by city.

destinations_sf = destinations %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 6668) %>% 
  st_transform(6677)

destinations_sf %>% mutate(colour = case_when(label == "SensÅ-ji Temple" ~ "goldenrod1",
                                              label == "Asakusa Shrine" ~ "goldenrod1",
                                              TRUE ~ "maroon")) %>% 
  tm_shape() +
  tm_dots(col = "colour") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Expedia Destinations")
```

The two destinations Asakusa Shrine and Senso-ji are placed right next to each other. While they are technically two different places, they usually serve as part of the same destination. Since practically every trip made to these locations will always put these destinations within the same trip, one of those destinations should be viewed as a duplicate.

```{r Remove geographically duplicate destinations}
destinations_sf = destinations_sf %>% 
  filter(label != "Asakusa Shrine")

destinations = destinations %>% 
  filter(label != "Asakusa Shrine")
```

```{r Show grid}
tm_shape(yamanote_area_grid) + tm_polygons(alpha = 0.1) +
  tm_shape(destinations_sf) + tm_dots(col = "turquoise", size = 0.05) +
  tm_shape(hotels_sf) + tm_dots(col = "maroon", size = 0.02) +
  tm_basemap(server = "OpenStreetMap", alpha = 0.3) +
  tm_layout(title = "Geometries of grid, hotels and destinations")
```

In all, these are the objects used for analyses.

##Grid statistics  
In total, `r yamanote_area_grid %>% length()` grid hexagons were created. The hotels are binned into these grids.

```{r Distribution of hotels in grid}
### the _aggr suffix means that the dataset is aggregated.
### (not aggravated) (nor aggroed)
### (whatever)

# Zeroes are inconclusive: take away all zero-price hotels
# hotels_sf = hotels_sf %>% filter(price.strikeout > 0)

hotels_aggr = st_join(hotels_sf, yamanote_area_grid) %>% 
  replace_na(list(grid.id = -1)) %>% 
  st_set_geometry(NULL) %>% 
  group_by(grid.id) %>% 
  summarise(price.lead.average = mean(price.lead),
            price.lead.median = median(price.lead),
            price.lead.sd = sd(price.lead),
            no.hotels = n())

hotels_aggr_sf = yamanote_area_grid %>% 
  left_join(hotels_aggr)

hotels_aggr %>% 
  filter(grid.id > 0) %>% 
  gather("key", "value", -grid.id, -no.hotels) %>% 
  ggplot() +
    geom_boxplot(aes(key, value)) +
  scale_x_discrete(labels = c("Average Price", "Median Price", "Standard Deviation")) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  labs(title = "Distribution of grid prices",
       subtitle = "Average, median prices and standard deviation") +
  coord_flip()
```

This is the distribution of hotels in the grids. The most populous grid has `r max((hotels_aggr %>% filter(grid.id > 0))$no.hotels)`.

##Grid average prices  
```{r Grid average prices}
hotels_aggr_sf %>%
  select(grid.id, everything()) %>% 
  tm_shape() + 
  tm_fill(col = c("price.lead.average", "price.lead.median", "price.lead.sd"), 
          style = "jenks", 
          colorNA = "#CCCCCC", 
          alpha = 0.6) +
  tm_basemap(server = "OpenStreetMap", alpha = 0.4)
```
*Perhaps it would be a good idea to overlay the stations and lines on this.*

#Spatial Autocorrelation

*Explain spatial autocorrelation here*

```{r Spatial Autocorrelation}
hotels_aggr_sp = as(hotels_aggr_sf %>% filter(!is.na(price.lead.average)), "Spatial")

hotels_nb = poly2nb(hotels_aggr_sp)
hotels_wt = nb2listw(hotels_nb, style = "W", zero.policy = T)

hotels_lag = lag.listw(hotels_wt, hotels_aggr_sp$price.lead.average)

ggplot() +
  geom_point(aes(x = hotels_aggr_sp$price.lead.average, y = hotels_lag))
```

There seems to be a correlation between grid average room rates and those of their neighbours, although that correlation seems to quickly deteriorate for pricier grids. *Can we make the conclusion that higher-priced hotels (higher priced grids) are more influenced by intrinsic factors rather than locational ones?*

##Moran's I
```{r Moran}
moran.test(hotels_aggr_sp$price.lead.average, hotels_wt, zero.policy = T)
```

*Here we see that there is a just-strong-enough correlation to suspect some spatial factor?*

##Local Moran
*To look at the local amount of clustering*
```{r}
moran_local = localmoran(hotels_aggr_sp$price.lead.average, hotels_wt, zero.policy = T)
hotels_aggr_sp %>% 
  st_as_sf() %>%
  mutate("moran.local" = moran_local[,1]) %>%
  st_set_geometry(NULL) %>% 
  select(grid.id, moran.local) %>% 
  left_join(hotels_aggr_sf, .) %>% 
  tm_shape() +
    tm_fill(col = "moran.local", style = "jenks", palette = "-RdBu", colorNA = "#CCCCCC", alpha = 0.8) +
    tm_basemap(server = "OpenStreetMap", alpha = 0.4) +
    tm_layout(title = "LISA (local clustering)")
```
*Hmm...*

#Accessibilities  
```{r Accessibility of grids, eval=F}
otp_path_folder = here::here("data/OpenTripPlanner/")
otp_path = file.path(otp_path_folder,"otp-1.3.0-shaded.jar")
otp_path_data = otp_path_folder
otp_setup(otp = otp_path, 
          dir = otp_path_data, 
          memory = 6192, 
          router = "Tokyo")
otpcon = otp_connect() #May take a while to load

from = yamanote_area_grid %>% 
  st_centroid() %>% 
  st_transform(4326)
to = destinations_sf %>% 
  st_transform(4326)

fromPlace = from %>% st_coordinates() %>% as_tibble() %>% mutate(fromID = from$grid.id) %>% slice(rep(1:n(), times = nrow(to)))
toPlace = to %>% st_coordinates() %>% as_tibble() %>% mutate(toID = to$extrainfo) %>% slice(rep(1:n(), each = nrow(from))) 

pb = progress_estimated(nrow(toPlace), 5)

get_itenerary = function(fromY, fromX, toY, toX, fromID, toID) {
  if(!is.null(pb)) pb$tick()$print()
  from_ = str_glue("{fromY},{fromX}")
  to_   = str_glue("{toY},{toX}")
  
  response = GET(url = "http://localhost:8080",
                 path = "otp/routers/Tokyo/plan",
                 query = list(fromPlace = from_,
                              toPlace   = to_,
                              time      = "6:00pm",
                              date      = "2019-05-07",
                              preferredAgencies = "TokyoMetro",
                              maxTransfers = "5")) %>% 
    content()
  
  if(is.null(response$plan)) return(NULL)
  
  response$plan$itineraries %>% 
    map(as_tibble) %>%  
    bind_rows(.id = "option") %>%
    mutate(startTime = as.POSIXct(startTime/1000, origin = "1970-01-01"),
           endTime   = as.POSIXct(endTime/1000,   origin = "1970-01-01")) %>%
    mutate(leg.distance = map(legs, "distance") %>% unlist(),
           leg.mode     = map(legs, "mode") %>% unlist(),
           leg.routeId  = map(legs, "routeId", .default = NA) %>% unlist(),
           leg.from     = map(legs, "from"),
           leg.to       = map(legs, "to")) %>%
    mutate(leg.from.stopId = map(leg.from, "stopId", .default = "Origin"),
           leg.to.stopId   = map(leg.to,   "stopId", .default = "Destination"),
           leg.from.stopCode = map(leg.from, "stopCode", .default = "none"),
           leg.to.stopCode   = map(leg.to,   "stopCode", .default = "none")) %>% 
    group_by(option) %>% 
    mutate(leg = row_number()) %>% 
    ungroup() %>% 
    select(-walkLimitExceeded, -elevationLost, -elevationGained, -legs, -leg.to, -leg.from, -tooSloped) %>% 
    mutate(fromID = fromID,
           toID = toID)
}

grid_routes = pmap_dfr(list(fromX = fromPlace$X,
                            fromY = fromPlace$Y,
                            toX   = toPlace$X,
                            toY   = toPlace$Y,
                            fromID= fromPlace$fromID,
                            toID  = toPlace$toID),
                            get_itenerary)
pb$stop()

grid_routes = otp_plan(otpcon = otpcon,
                       fromPlace = fromPlace,
                       toPlace = toPlace,
                       fromID = fromPlace$grid.id %>% as.character(),
                       toID = toPlace$extrainfo %>% as.character(),
                       mode = c("WALK", "TRANSIT"),
                       date_time = as.POSIXct(strptime("2019-06-04 17:00", "%Y-%m-%d %H:%M")),
                       get_geometry = T,
                       numItineraries = 1,
                       ncores = 4)
```

```{r Accessibility of grids rds}
grid_routes = read_rds(here::here("data/grid_routes.rds"))

from = read_rds(here::here("data/from.rds"))
to = read_rds(here::here("data/to.rds"))
fromPlace = read_rds(here::here("data/fromPlace.rds"))
toPlace = read_rds(here::here("data/toPlace.rds"))
```

```{r Investigate routes}
# missing destinations/grids: which?

grid_missing = from %>% 
  mutate(included = grid.id %in% grid_routes$fromPlace) %>% 
  filter(!included)

destinations_missing = to %>% 
  mutate(included = extrainfo %in% grid_routes$toPlace) %>% 
  filter(!included)

tm_shape(grid_missing) + tm_dots(col = "maroon", title = "Missing grids") +
  tm_shape(destinations_missing) + tm_dots(col = "turquoise", title = "Missing destinations") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.4) +
  tm_layout(title = "Missing geometries")
```

```{r Tracemap}
### dataisbeautiful
trace_routes = grid_routes %>% 
  st_zm() %>% 
  group_by(fromPlace, toPlace) %>% 
  summarise()

tm_shape(trace_routes) +
  tm_lines(lwd = 1.25, alpha = 0.07, col = "white") +
  tm_basemap(server = "OpenStreetMap", alpha = 0.2) +
  tm_layout(bg.color = "black", title = "Tracemap of routes from grid centres to destinations")
```

```{r Average times}
grid_aggr_time = grid_routes %>% 
  st_set_geometry(NULL) %>% 
  group_by(fromPlace, toPlace) %>% 
  summarise(duration = first(duration)) %>% 
  group_by(fromPlace) %>%
  summarise(duration = mean(duration)/60) %>% 
  mutate(fromPlace = as.integer(fromPlace)) %>% 
  right_join(yamanote_area_grid, by = c("fromPlace" = "grid.id")) %>% 
  select(duration, everything()) %>% 
  st_as_sf()

tm_shape(grid_aggr_time) +
  tm_fill(col = "duration", style = "jenks", n = 10, palette = "-inferno", alpha = 0.7) +
  tm_basemap(server = "OpenStreetMap", alpha = 0.4) +
  tm_layout(title = "Accessibility of grid-centers by mean time taken")

# very subtle patterns can be seen here. For example, Tokyo has a high level of accessibility, and this high level emanates from Tokyo through the two main JR line-clusters: the Tokaido Line-Tohoku Line cluster (N-S), and the Chuo Line cluster (E-W). Some grids have very good accessibility because one of the destinations is in the grid. This shows that the averaging method is not good enough, because the results are not "spread out" enough.
```
